<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dp优化整理</title>
    <url>/2023/06/30/dp%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a>决策单调性</h2><p>决策单调性通常使用四边形不等式证明。</p>
<p>（似乎以前有一个很好的关于证明四边形不等式的课件）</p>
<p>概念</p>
<ul>
<li>四边形不等式：即对于任意 $l \le l’ \le r’ \le r $ 都满足 $w(l,r)+w(l,r’) \ge w(l,r’)+w(l’,r)$。</li>
<li>区间包含单调性：即对于任意 $l \le l’ \le r’ \le r $ 都满足 $w(l,r) \ge w(l’,r’)$ 。</li>
</ul>
<h3 id="区间类2D1D型动态规划"><a href="#区间类2D1D型动态规划" class="headerlink" title="区间类2D1D型动态规划"></a>区间类2D1D型动态规划</h3><p>形如 $dp_{l,r}=\min\limits_k(dp_{l,k}+dp_{k+1,r})+w(l,r)$ 。</p>
<p> 直接转移时间复杂度为 $O(n^3)$ 。</p>
<p>Lemma: $w(l,r)$ 同时满足四边形不等式和区间包含单调性，则可以证明状态 $f_{l,r}$ 满足四边形不等式。</p>
<p>Theorem:若状态 $f$ 满足四边形不等式，则对于状态 $f_{l,r}$ 的最优决策点 $m_{l,r}$ 有 $m_{l,r-1} \le m_{l,r} \le m_{l+1,r}$ 。</p>
<p><a href="https://oi-wiki.org/dp/opt/quadrangle/#%E5%8C%BA%E9%97%B4%E7%B1%BB2d1d%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">证明</a>。</p>
<p>枚举的决策点总数为 ：</p>
<script type="math/tex; mode=display">
\sum \limits_{1\le l\le r\le n}m_{l+1,r}-m_{l,r-1}=\sum\limits_{i=1}^nm_{i,n}-m_{1,n-i+1} \le n^2</script><p>时间复杂度 $O(n^2)$ 。</p>
<h3 id="分治优化"><a href="#分治优化" class="headerlink" title="分治优化"></a>分治优化</h3><p>形如 $f_i=\min\limits_{j&lt;i}(g_j+w(j,i))$ 。</p>
<p>即当前的转移不依赖于同层的dp值，因此我们可以任意决定同层内的dp计算顺序，常见于分层转移的二维dp。</p>
<p>当 $w(l,r)$ 满足四边形不等式，则决策点依然满足单调性 $m_i\le m_{i+1}$<br>考虑分治，每次选取mid算出其决策点，则两边的决策点上界/下界得到更新。</p>
<p>对于分治在同一层的多个子问题（即长度规模相同的），总的枚举量为 $O(n)$ 。</p>
<p>共 $O(\log n)$ 层，时间复杂度 $O(n\log n)$ 。</p>
<p><a href="https://codeforces.com/problemset/problem/868/F">Yet Another Minimization Problem</a></p>
<h3 id="1D1D动态规划"><a href="#1D1D动态规划" class="headerlink" title="1D1D动态规划"></a>1D1D动态规划</h3><p>形如 $f_i=\min\limits_{j&lt;i}(f_j+w(j,i))$ 。</p>
<p>当$w(i,j)$ 满足四边形不等式时，决策点单调。</p>
<p>证明：</p>
<p>设 $f_i$ 的最优决策点为 $m_i$ ，设 $i’&lt;i$。<br>根据四边形不等式可知 $w（i’,i+1)+w(m_i+i) \ge w(i’+i)+w(m_i,i+1)$。</p>
<p>由于 $m_i$ 是最优决策点，则有 $f_{m_i}+w(m_i,i) \le f_{i’}+w(i’,i)$ 。</p>
<p>根据上述两式，可得，$f_{m_i}+w(m_i,i+1) \le f_{i’}+w(i’,i+1)$<br>即 $m_{i+1} \ge m_i$。</p>
<p>双指针即可，时间复杂度 $O(n)$ 。</p>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>形如 $f_i=\min\limits_{j}({a_i\times b_j+c_i+d_j})$。<br>其中 $a_i \times b_j$ 同时与 $i,j$ 有关。</p>
<p>当 $j$ 是最优决策点时，通过移项可以得到 $-d_j=a_i\times b_j -f_i +c_i$<br>我们可以把上述式子看做 $y=kx+b$ 的形式。</p>
<p>则，点 $(x,y)$ 等价于 $(b_j,-d_j)$ ，而关于 $i$ 的量转化为斜率 $a_i$ （以及一些无关紧要的常量 $c_i$ ）。</p>
<p>则每个决策点都可以看做坐标系上一点，对于每个 $i$ 我们用一个固定斜率的直线去穿过这些点，找到一个点使得截距最大或最小。</p>
<p>而坐标系上的很多决策点是永远不可能最优的，我们可以将其丢弃。可以证明，最终有用的决策点在坐标系上是一个凸包，斜率具有单调性。<br>而对于一条斜率为 $k$ 的直线，在凸包上截距是一个单谷函数。</p>
<p>根据具体问题分析是上凸包还是下凸包。(大概和取 $\min$ 或是 $\max$ 有关吧)。</p>
<p>值得注意的是，$b_j$ 即 $X(j)$ 最好为单增，方便维护。</p>
<p>当 $X(j)$ 不具有单调性时，在凸包上插入点集就无法使用单调队列去维护了（可以<a href="https://www.luogu.com.cn/problem/P4027">cdq分治</a>，平衡树之类的但我不会）。</p>
<p>当 $X(j)$ 和斜率 $k$ 都具有单调性，即决策具有单调性，每次都可以直接弹出队首更新答案。</p>
<p><a href="https://www.luogu.com.cn/problem/P3195">[HNOI2008] 玩具装箱</a><br><a href="https://www.luogu.com.cn/problem/P2900">[USACO08MAR] Land Acquisition G</a><br> <a href="https://www.luogu.com.cn/problem/P5785">[SDOI2012] 任务安排</a>（当斜率不具有单调性，可以二分。）<br><a href="https://zhuanlan.zhihu.com/p/622041814">套路化解决斜率优化问题</a><br><a href="https://www.cnblogs.com/Xing-Ling/p/11210179.html">斜率优化详解</a></p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>矩阵快速幂的运用需要证明矩阵乘法具有结合律，并且它通常不具有交换律。<br>一个 $1\times n$ 的矩阵与 $n\times n$ 的矩阵相运算时间复杂度是 $n^2$ 的。<br><a href="https://www.luogu.com.cn/problem/P3328">音质检测</a><br>运用这样的思想，可以运用树剖把序列问题转化为树上问题，这就是ddp。ddp多可以用于维护修改，我们在一条重链/轻链上做矩阵乘法，手动维护链顶的父亲的dp值。<br><a href="https://www.luogu.com.cn/problem/P4719">模板</a><br>运用黑科技全局平衡二叉树，可以将模板题去掉一个 $\log$ 。<br><a href="https://www.luogu.com.cn/problem/P4751">模板加强版</a><br>当一些可以使用ddp的题目上的修改只对单次询问有效时，可以不使用ddp，而是用倍增维护。<br><a href="https://www.luogu.com.cn/problem/5024">保卫王国</a></p>
<h2 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h2><p>譬如<a href="https://xxzx.moe/2023/04/27/pkuwc2018minimax/">[PKUWC2018]Minimax</a><br>使用线段树合并加速。</p>
<h2 id="wqs二分"><a href="#wqs二分" class="headerlink" title="wqs二分"></a>wqs二分</h2><p>解决的是当dp形如 $dp_{i,j}=\max\limits_k{dp_{k,j-1}+w(k,i)}$ 即，有取 $m$ 个数的限制的问题。它需要满足选 $i$ 个物品的最大值 $g(i)$ 是一个凸包，权值和斜率随着选的物品数量单调变化。<br>对于 $g(i)$ 这个凸包，我们相当于要求出 $g(m)$ ，即，找到 $(m,g(m))$ 这个点。</p>
<p>下文假设都是上凸包，下凸包反一反即可。</p>
<p>根据上凸包的性质，随着点的横坐标增大，切这个点的直线的斜率也递减。反过来想，对于给定的斜率，如何知道它是凸包上哪一点的切线呢？<br><img src="https://xxzx.moe/wp-content/uploads/2023/08/dp优化整理1.png" alt=""><br>我们会发现，当这条直线穿过它相切的点 $(x,g(x))$ 的时候，截距 $b$ 最大。$g(x)=kx+b$ 。移项一下， $b=kx-g(x)$ 。我们要求的就是最大的 $b$ ，而取到这个最大的 $b$ 的 $x$ 就是我们要找的点了。<br><img src="https://xxzx.moe/wp-content/uploads/2023/08/dp优化整理2.png" alt=""><br>设 $f(x)=kx-g(x)$ 。我们发现， $g(x)$ 其实就是选 $x$ 个数的权值，我们不妨把选中每个数的权值都加上 $k$ ，这样 $f(x)$ 就转化为无选择物品数限制的新问题了，我们通常可以用更低复杂度的做法进行求解。</p>
<p>我们可以不断二分斜率进行调整，找到点 $m$ 及其对应的  $f(m)$，从而求出 $g(m)$ 。</p>
<p> 实现细节：</p>
<p>一条固定斜率的直线有可能会切到很多点，我们需要合理地判断哪里加等号，比如横坐标尽可能取更大的/更小的，与二分斜率部分相对应。<br><a href="https://www.luogu.com.cn/problem/P4983">忘情</a><br><a href="https://www.luogu.com.cn/problem/P2619">Tree I</a><br><a href="https://xxzx.moe/2024/02/15/arc168e/">ARC168E题解</a></p>
<h2 id="slope-trick"><a href="#slope-trick" class="headerlink" title="slope trick"></a>slope trick</h2><p><a href="https://www.luogu.com.cn/problem/P4597">序列</a></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置 vscode</title>
    <url>/2023/09/09/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-vscode/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cb694767f02b957af74f8f412c20c7bb1467a6af8a6579a9b30dad831cf3ae8f">ffce6ed2b9da911e9229c3045da1ad40f2bfad9d3722bbdca014e081a8d1e46501a31f25256ff2914e2df6a2411b901b49177c8ee4e3da7e1267864baa3188cd0f7f5db5f2a1e1163abaaccb5d5e755b136a5fc31e8a4e37e0e1272c8f430defe6fb265ccddf995f78991a4e4949d592dd9d7cbbc5136f1ae65135c8ea5dd685d8925130257c21bbd0e044db895cfc2d2f8775fbf1f5852575492d5aa376e882c721abe505224dc2c023d8e1fd8e17085c19ece70d5799cbdb9524385766fa600b9e3dd32c8cb65d35451ebec0e52c6a94a438b70e3be55a66da4d17e61bca43fcc0d36d55d8e9a4880401840b6ced83234770f7fba9ddbb24af78c188181b7859d5869bf349bd1b53b14132f0c411faa5a9a5115b7dc22fc6447e3b2476ceeb98129030ecbcffae399a981857fbfd4051a55af8bf0ef48789012b532b3917c69251137204bc5f35b248c50a3da58ec843e34980986c6570449ca13496ac787069ed509d5377ab227136af60717a09cddc7ac1fc43dea8ae40b12fd4f2575a47b8a55761415e0d88b067f684aa17f1caa6f31dfcbf651be9ed643762293cb34d5a625d15b26e2dfde270dcb409c959ca52cc436d3668129fd56b32c8891613fa9f927fcbf2717a8cac505d314cfce48ff4fb6701e06c876caa37c4a3b2068911aaab04deadd655d5af74cf6bb40d5eb57768601d0b55ad3d301f08d438e4e93412f187fdeb22c60abb0861ea400547cb3e76e5d655022045be3aaceda19eeae004e41002746a270656110aa91027e9b1e8738e87b9131ed215c8119fdb770f7ecc8d3f35e2de9c049156da5b738b53a021bb8fa720f26c9633ebb2b8c840960dc01f092b1313df38428245fff3a4cea4b12ed6644641686afa1a1c372df75a65fa32ee83c8d37ca77e37c168876bc859341f9ca2080983beb6aee39c6f7f789a0b368baaa570d8cb97921de6e9d7c0c1e372501328d455c6eb97100240c7993c88147b563ee050a90454d8f7b68618a5eb66836263e4c774f5a497d875a590df94b8165800843978d2d4dcd0b896a99fe45f5ad478e4d604f65bf869b0e4490b68ccb0894f6adecb2a79ae739e65b2f91e341bcdc50c1ad187f8a691f094dd63b261224bc59714831777de55f409385db2bb54d442c2c66c26aa28ed94d56a8fb2ffab29d015398c874aa1b6c558984f21405401472817acc161da24972bfa4159b526bee0f62fb2eef12769bc96deb3bfd8bdffd4c8aa946d933bb872f5291120514f70761a17e88916ea421b057060b1f824f7ed69456efa8ec8cce788f236946b390877475164f775a7eb715aae1668244cbff3ba87cbd521cd41aeffe748680437f71b1f11fc239fae318c0a97b2b85f6905835b2d3917a4981cfe24a8d64420604741a625ee0e0a1e8f68e2f3abb5b8fac14f1103ec98c809407c5b42f99eecd05daca482195c857172c1c8237aa61af67983fd4e535c507b087e798bf8e645159278f4151c1d302d12dfe8aa3e6a4d3f76d5c37e69d5fa0f4f624f312b85d711359baf8e03d99bbbca936e174dc8aafed86315372534a680d87028f9b3fe4dc2307bb6202a9c44393c478c2fdca969ae5bfc6e728ada9b1adee75b17c6ff31fa6d78ff926addebaaca52509e6013b1b6ecdefb6e3a18da05926920b3cd9cf4e1dcff708fa9db9c95407f128ddc408a073fc82b3f04b8ca2da724825f3a4e2eb33949efa81244f077efa4ccbf943063326441c1168ec5d999659654ea174f469fe257b3f8ff6029fad91b0b51e042b369394d8aae649e06e05e1e977a7f476742af45656327b2aabf7f52f065c3f52c93a976986205692b6cdd47d96c6c0ef5d7b4002389fc7f8caef04dc26cb89a38a0187ef39336a078c42cc5081f8709f259d630444758be0eff3931036adae52f4b3a04d7339d64c16b1390c80d83da10d0a443b79dae12aa2bb9dc6f26cdf1edace3cbf7ff6400b68cad11a97036ac2d0c34a11e6d99822372dd4d999fed987cc1bdce6bdd2c6725a41823ad580306dbea668ea80734ed77842506547a2efcba0957130656ee272068a087ec2a4e7729bf5fba674b6e65474914b33de83f663215b51fec39c5dc9d1412c5072d8666580fdeaa9280dd5d7ba0d06450a33f3dfcb9254eba32d82e6a76bef836ce35ee4e859517ce51c9b95884b79338b9fa974bc6a3f2703df8c18b5994d994c1c59836d4f1ef43200463c30654f1f6fd6cb43752eda97bb8745de3a22d13c7d11b93fa07918acab032b954c3ea327975227f66eae0516c7d4978112fb8548585908aa255d7cb5c2f986ef0a05d78ecfabba38c659c1e596564a9222ea70a6d9b7e65e6b9b8358462e8758e5993d19530d7b0a1852438156ff41d67a636c7b110fed475cce552112f9a8b290b29c1836d9b325c2e62fdf3aebcdeac71c8eded7fd27d11e1daf9dfee32bfa52d6141f88312960511b5048c585e67bcb182489fd6dd3b92ab0167f7ca51e84545d1daa82b0d01f1b2825d6915f2c6a1ba2cd2a2be8ce2646388031c831eea25d41fa8457992d06c58df5ef0ade68655e0011bd2f66c94ca0529206ca75b6eac469f41a16707</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>平衡树学习笔记</title>
    <url>/2024/02/25/%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="平衡树定义"><a href="#平衡树定义" class="headerlink" title="平衡树定义"></a>平衡树定义</h1><p>二叉搜索树是一种二叉树的树形数据结构，其满足任意点的权值大于其左儿子（若存在）权值，且小于右儿子（若存在）权值。</p>
<p>根据这个性质，我们可以很容易实现如下功能：</p>
<ul>
<li>查找最值</li>
<li>搜索特定元素</li>
<li>寻找第 $k$ 大</li>
<li>求元素排名</li>
</ul>
<p>上述时间复杂度都是 $O(h)$ 的。其中 $h$ 为树高。</p>
<p>一棵普通的二叉搜索树并不够平衡，树高可以卡到 $O(n)$。这并不理想，而平衡树就是通过一系列平衡调整操作使得树高维持在 $O(\log n)$。</p>
<h1 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h1><p>Treap 是一种弱平衡的二叉搜索树。其权值满足二叉搜索树的性质，随机权值满足堆（下文统一为小根堆）的性质。</p>
<h2 id="有旋-Treap"><a href="#有旋-Treap" class="headerlink" title="有旋 Treap"></a>有旋 Treap</h2><p>依靠旋转操作来维护树的平衡。</p>
<h3 id="前置约定"><a href="#前置约定" class="headerlink" title="前置约定"></a>前置约定</h3><p>对于节点 $i$，定义 $ls,rs,val,rk,w,sz$ 分别为左儿子，右儿子，权值，随机权值，权值个数，子树大小。</p>
<p>定义 $cnt$ 为节点总数，$rt$ 为根节点。</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>通过不改变树性质的同时改变树的层数。如图：</p>
<p> <img src="https://oi-wiki.org/ds/images/treap-rotate.svg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; sz[id]=w[id]+sz[ls[id]]+sz[rs[id]]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lrotate</span><span class="params">(<span class="type">int</span> &amp;id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=rs[id];</span><br><span class="line">    rs[id]=ls[t], ls[t]=id;</span><br><span class="line">    <span class="built_in">pushup</span>(id), <span class="built_in">pushup</span>(t);</span><br><span class="line">    id=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rrotate</span><span class="params">(<span class="type">int</span> &amp;id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=ls[id];</span><br><span class="line">    ls[id]=rs[t], rs[t]=id;</span><br><span class="line">    <span class="built_in">pushup</span>(id), <span class="built_in">pushup</span>(t);</span><br><span class="line">    id=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入节点跟普通二叉搜索树类似，但需要通过旋转操作满足堆的性质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) &#123;</span><br><span class="line">        id=++cnt;</span><br><span class="line">        ls[id]=rs[id]=<span class="number">0</span>;</span><br><span class="line">        val[id]=x;</span><br><span class="line">        rk[id]=<span class="built_in">rd</span>();</span><br><span class="line">        w[id]=sz[id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[id]++;</span><br><span class="line">    <span class="keyword">if</span>(val[id]==x) <span class="keyword">return</span> w[id]++, <span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(val[id]&lt;x) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(rs[id],x);</span><br><span class="line">        <span class="keyword">if</span>(rk[id]&gt;rk[rs[id]]) <span class="built_in">lrotate</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">insert</span>(ls[id],x);</span><br><span class="line">        <span class="keyword">if</span>(rk[id]&gt;rk[ls[id]]) <span class="built_in">rrotate</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>分类讨论，若当前节点有多个值，就直接减去。若只有左儿子或右儿子，就直接将儿子提上来。否则，讨论左右儿子的随机权值，将其中一个点旋转上来作为根，递归去删需要删除的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(<span class="type">int</span> &amp;id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[id]==x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[id]&gt;<span class="number">1</span>) <span class="keyword">return</span> w[id]--, sz[id]--, <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ls[id]||!rs[id]) <span class="keyword">return</span> id=ls[id]+rs[id], <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(rk[ls[id]]&lt;rk[rs[id]]) &#123;</span><br><span class="line">            <span class="built_in">rrotate</span>(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">del</span>(id,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">lrotate</span>(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">del</span>(id,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val[id]&lt;x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">del</span>(rs[id],x)) <span class="keyword">return</span> sz[id]--, <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">del</span>(ls[id],x)) <span class="keyword">return</span> sz[id]--, <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询排名-查询前-k-大-查询前驱-查询后继"><a href="#查询排名-查询前-k-大-查询前驱-查询后继" class="headerlink" title="查询排名/查询前 $k$ 大/查询前驱/查询后继"></a>查询排名/查询前 $k$ 大/查询前驱/查询后继</h3><p>与二叉搜索树操作相同，在此不赘述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qrk</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[id]==x) <span class="keyword">return</span> sz[ls[id]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[id]&lt;x) <span class="keyword">return</span> sz[ls[id]]+w[id]+<span class="built_in">qrk</span>(rs[id],x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">qrk</span>(ls[id],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qkth</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=sz[ls[id]]) <span class="keyword">return</span> <span class="built_in">qnum</span>(ls[id],x);</span><br><span class="line">    <span class="keyword">if</span>(w[id]+sz[ls[id]]&lt;x) <span class="keyword">return</span> <span class="built_in">qnum</span>(rs[id],x-w[id]-sz[ls[id]]);</span><br><span class="line">    <span class="keyword">return</span> val[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qpre</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[id]&lt;x) ans=val[id], <span class="built_in">qpre</span>(rs[id],x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">qpre</span>(ls[id],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsub</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[id]&gt;x) ans=val[id], <span class="built_in">qsub</span>(ls[id],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无旋Treap——fhq-treap"><a href="#无旋Treap——fhq-treap" class="headerlink" title="无旋Treap——fhq treap"></a>无旋Treap——fhq treap</h2><p>依靠分裂与合并维护树的平衡，省去了旋转操作，使得它支持维护序列、可持久化等特性。</p>
<p>代码比旋转 Treap 更好写，但常数更大。</p>
<h3 id="前置约定-1"><a href="#前置约定-1" class="headerlink" title="前置约定"></a>前置约定</h3><p>对于节点 $i$，定义 $ls,rs,val,rk,sz,lz$ 分别为左儿子，右儿子，权值，随机权值，子树大小，旋转的懒标记。</p>
<p>与旋转 Treap 不同的是，无旋 Treap 相同的权值不合并成一个节点。</p>
<p>定义 $cnt$ 为节点总数，$rt$ 为根节点。</p>
<p>定义 pushup 和 newnode 函数如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; sz[id]=sz[ls[id]]+sz[rs[id]]+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> cnt++, val[cnt]=x, rk[cnt]=<span class="built_in">rd</span>(), sz[cnt]=<span class="number">1</span>, cnt; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="按值分裂"><a href="#按值分裂" class="headerlink" title="按值分裂"></a>按值分裂</h3><p>此函数将以 $id$ 为根的子树分裂成 $\le x$ 和 $&gt; x$ 两部分，并返回两部分的新根。</p>
<p>分类讨论根节点的情况，则其左儿子或右儿子一定整体属于某一部分，递归分裂另一部分子树即可。</p>
<p><img src="https://oi-wiki.org/ds/images/treap-none-rot-split-by-val.svg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PII <span class="title">splitv</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(val[id]&lt;=x) &#123;</span><br><span class="line">        PII res=<span class="built_in">splitv</span>(rs[id],x);</span><br><span class="line">        rs[id]=res.first, <span class="built_in">pushup</span>(id);</span><br><span class="line">        <span class="keyword">return</span> &#123;id,res.second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PII res=<span class="built_in">splitv</span>(ls[id],x);</span><br><span class="line">        ls[id]=res.second, <span class="built_in">pushup</span>(id);</span><br><span class="line">        <span class="keyword">return</span> &#123;res.first,id&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按排名分裂"><a href="#按排名分裂" class="headerlink" title="按排名分裂"></a>按排名分裂</h3><p>此函数将以 $id$ 为根的子树分裂成 $\le x,&gt;x$ 两部分。</p>
<p>分裂讨论排名为 $x$ 的节点在哪个位置。其实现和旋转 Treap 中查询第 $k$ 大相似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PII <span class="title">splitrk</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=sz[ls[id]]) &#123;</span><br><span class="line">        PII res=<span class="built_in">splitrk</span>(ls[id],x);</span><br><span class="line">        ls[id]=res.second, <span class="built_in">pushup</span>(id);</span><br><span class="line">        <span class="keyword">return</span> &#123;res.first,id&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==sz[ls[id]]+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> p=rs[id];</span><br><span class="line">        rs[id]=<span class="number">0</span>, <span class="built_in">pushup</span>(id);</span><br><span class="line">        <span class="keyword">return</span> &#123;id,p&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    PII res=<span class="built_in">splitrk</span>(rs[id],x-sz[ls[id]]<span class="number">-1</span>);</span><br><span class="line">    rs[id]=res.first, <span class="built_in">pushup</span>(id);</span><br><span class="line">    <span class="keyword">return</span> &#123;id,res.second&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>将以 $x$ 为根的树和以 $y$ 为根的树合并，必须满足 $x$ 中所有节点的值小于等于 $y$ 中所有节点的值。由于合并的两个 Treap 通常都是原来从同一个 Treap 分裂出的，所以满足该性质。</p>
<p>合并过程中，需要使随机权值满足小根堆性质，因此分类讨论：</p>
<p>若 $x$ 的随机权值比 $y$ 小，那么 $x$ 需要做新树的根节点，并且为了满足二叉搜索树的性质，$y$ 与 $x$ 的右子树进行合并。反之，$y$ 做新树的根节点，$x$ 与 $y$ 的左子树合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(rk[x]&lt;rk[y]) &#123;</span><br><span class="line">        rs[x]=<span class="built_in">merge</span>(rs[x],y), <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ls[y]=<span class="built_in">merge</span>(x,ls[y]), <span class="built_in">pushup</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>插入权值 $x$。</p>
<p>将树按值分裂为 $&lt;x$ 和 $\ge x$ 两部分，再合并回去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    PII res=<span class="built_in">splitv</span>(rt,x);</span><br><span class="line">    rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(res.first,<span class="built_in">newnode</span>(x)),res.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>删除一个权值 $x$。</p>
<p>将树分裂成 $<x,=x,>x$ 三部分，将第二部分的根删去，并合并三棵树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    PII res1=<span class="built_in">splitv</span>(rt,x<span class="number">-1</span>), res2=<span class="built_in">splitv</span>(res1.second,x);</span><br><span class="line">    <span class="type">int</span> l=res1.first, mid=res2.first, r=res2.second;</span><br><span class="line">    mid=<span class="built_in">merge</span>(ls[mid],rs[mid]);</span><br><span class="line">    rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(l,mid),r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询排名-查询前-k-大-查询前驱-查询后继-1"><a href="#查询排名-查询前-k-大-查询前驱-查询后继-1" class="headerlink" title="查询排名/查询前 $k$ 大/查询前驱/查询后继"></a>查询排名/查询前 $k$ 大/查询前驱/查询后继</h3><p>依旧是二叉搜索树基本操作，下面给出非递归版本和其他实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qrk</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    PII res=<span class="built_in">splitv</span>(rt,x<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans=sz[res.first]+<span class="number">1</span>;</span><br><span class="line">    rt=<span class="built_in">merge</span>(res.first,res.second);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qkth</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=sz[ls[id]]) id=ls[id];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==sz[ls[id]]+<span class="number">1</span>) <span class="keyword">return</span> val[id];</span><br><span class="line">        <span class="keyword">else</span> x-=sz[ls[id]]+<span class="number">1</span>, id=rs[id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _qkth(<span class="type">int</span> x) &#123;</span><br><span class="line">    PII res1=<span class="built_in">splitrk</span>(rt,x<span class="number">-1</span>), res2=<span class="built_in">splitrk</span>(res1.second,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=val[res2.first];</span><br><span class="line">    <span class="built_in">merge</span>(<span class="built_in">merge</span>(res1.first,res2.first),res2.second);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpre</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id=rt, ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(id) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val[id]&lt;x) ans=val[id], id=rs[id];</span><br><span class="line">        <span class="keyword">else</span> id=ls[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _qpre(<span class="type">int</span> x) &#123; <span class="keyword">return</span> <span class="built_in">qkth</span>(<span class="built_in">qrk</span>(x)<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsub</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id=rt, ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(id) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val[id]&gt;x) ans=val[id], id=ls[id];</span><br><span class="line">        <span class="keyword">else</span> id=rs[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _qsub(<span class="type">int</span> x) &#123; <span class="keyword">return</span> <span class="built_in">qkth</span>(<span class="built_in">qrk</span>(x+<span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>无旋 Treap 可以将区间建树，以下标作为权值插入 treap 中，满足中序遍历为这个区间。</p>
<p>依次插入元素，时间复杂度 $O(n\log n)$。</p>
<p>注意到 Treap 是笛卡尔树，因此按照笛卡尔树建树方法即可，时间复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[id]) <span class="built_in">dfs</span>(ls[id]);</span><br><span class="line">    <span class="keyword">if</span>(rs[id]) <span class="built_in">dfs</span>(rs[id]);</span><br><span class="line">    <span class="built_in">pushup</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) val[i]=i, rk[i]=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;rk[st[top]]&gt;rk[i]) p=st[top--];</span><br><span class="line">        ls[i]=p;</span><br><span class="line">        <span class="keyword">if</span>(top) rs[st[top]]=i;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    rt=st[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h3><p>需要使得树的中序遍历等于维护的序列。</p>
<p>将区间 $[l,r]$ 翻转的操作，可以将树分成 $[1,l-1],[l,r],[r+1,n]$ 三个区间，对中间的树进行翻转，再合并。暴力翻转显然不行，在节点上打上懒标记，访问到再下传即可。</p>
<p><img src="https://oi-wiki.org/ds/images/treap-none-rot-seg-flip-ex.svg" alt=""></p>
<p>在 split 和 merge 等函数中要及时下传懒标记，在此不展示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lz[id]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(ls[id],rs[id]);</span><br><span class="line">    lz[ls[id]]^=<span class="number">1</span>, lz[rs[id]]^=<span class="number">1</span>, lz[id]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    PII res1=<span class="built_in">splitrk</span>(rt,l<span class="number">-1</span>), res2=<span class="built_in">splitrk</span>(res1.second,r-l+<span class="number">1</span>);</span><br><span class="line">    lz[res2.first]^=<span class="number">1</span>;</span><br><span class="line">    rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(res1.first,res2.first),res2.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>在需要改变结构的地方新建节点即可。只在 split,merge,reverse,pushdown 中和非持久化有区别。</p>
<p>可以用这种方式理解：当某个节点的左右儿子有变化，就需要新建节点。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://oi-wiki.org/ds/treap/">Treap - OI Wiki</a></p>
<p><a href="https://www.cnblogs.com/zheyuanxie/p/fhq-treap.html">无旋树堆(FHQ-Treap)学习笔记 _</a></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>treap</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串基础整理</title>
    <url>/2023/09/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="前置算法"><a href="#前置算法" class="headerlink" title="前置算法"></a>前置算法</h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><p>定义 $s(l,r)$ 为 $s$ 的子串 $s[l\dots r]$ 。</p>
<h2 id="前缀函数与kmp"><a href="#前缀函数与kmp" class="headerlink" title="前缀函数与kmp"></a>前缀函数与kmp</h2><p>对于一个长度为 $n$ 的字符串 $s$ ，其前缀函数被定义为一个长度为 $n$ 的数组 $\pi$ 。其中 $\pi[i]$ 为长度为 $i$ 的前缀 $t$ 中的最长border长度，border即一个最长的非 $t$ 本身的子串，满足既是 $t$ 的前缀，又是 $t$ 的后缀。也可以用如下语言描述：</p>
<script type="math/tex; mode=display">\pi[i]=\max\limits_{k=1}^{i-1}(k:s[1\dots k]=s[i-(k-1)\dots i])</script><p>求 $\pi[i]$ 时，我们可以考虑从 $\pi[i-1]$ 继承过来，因为 $s(i-\pi[i]+1,i)$ 一定是先由 $s(i-\pi[i]+1,i-1)$ 匹配一个前缀 $s(1,\pi[i]-1)$ ，$s[i]$ 再和 $s[\pi[i]]$ 匹配。</p>
<p>即 $\pi[i]$ 是最大的满足条件的 $v$，其中 $s(1,v-1)$ 是 $s(1,\pi[i-1])$ 的后缀，需要满足 $s[v]=s[i]$ 。</p>
<p>如何找出所有的 $v$ 呢？</p>
<p>首先 $\pi[i-1]$ 一定是最大的 $v$ ，若它不满足条件，我们要继续找次大的 $v$ 。</p>
<p>因为 $s(1,\pi[i-1])=s(i-\pi[i-1]+1,i-1]$ ，所以 $\pi[\pi[i-1]]$ 同时是 $s(i-\pi[i-1]+1,i-1)$ 的border 。满足 $s(1,\pi[\pi[i])=s(i-\pi[\pi[i]],i-1)$ ，即，次大的 $v$ 就是 $\pi[\pi[i]]$ ，一直向下跳下去即可。</p>
<p>时间复杂度感性理解：时间复杂度与跳 $v$ 的次数相关，并且当前 $i$ 跳完后的 $\pi[i]=v$ 是继承到 $i+1$ 的，因此它能跳的步数每次会增加一次，而每次失配则跳一次，跳的步数 $\le$ n，因此时间复杂度 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="type">int</span> j=nxt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(s[j+<span class="number">1</span>]!=s[i]&amp;&amp;j) j=nxt[j];</span><br><span class="line">    nxt[i]=(s[j+<span class="number">1</span>]==s[i]? j+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kmp算法是前缀函数的运用，用于求 $s$ 中有多少子串和 $t$ 完全相同。<br>其实和上述算法是几乎相同的。</p>
<p>一些推论：<br>$s$ 的最小循环元长度为 $n-\pi[n]$ 。并且任何其他满足条件的循环元长度都是其倍数。</p>
<h2 id="exkmp-Z函数"><a href="#exkmp-Z函数" class="headerlink" title="exkmp(Z函数)"></a>exkmp(Z函数)</h2><p>对于一个长度为 $n$ 的字符串 $s$ ，其Z函数被定义为一个长度为 $n$ 的数组 $z$ 。其中 $z[i]$ 表示 $s$ 与 $s[i\dots n]$ 的LCP。</p>
<p>根据定义（当然依旧可以画图直观理解）：</p>
<script type="math/tex; mode=display">
s[i+(x)]\\
=s[l+(i+x-l)]\\
=s[0+(i+x-l)](x\le z[l]+l-i)\\
=s[i-l+(x)]\\
=s[0+(x)](x\le z[i-l])</script><p>因此 $z[i] \ge \min(z[l]+l-i,z[i-l])$ 。</p>
<p>考虑每一步转换的实际含义，我们发现能使得 $z[l]+l-i$ 越大的 $l(l&lt;i)$ 越优，设 $r=z[l]+l$，即找到最大的 $r$。</p>
<p>每次我们将 $z[i]\leftarrow \min(z[l]+l-i,z[i-l])$ ，然后暴力往后跳即可，因为 $r$ 递增，因此时间复杂度 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(z[l]+l&gt;=i) z[i]=<span class="built_in">min</span>(z[l]+l-i,z[i-l+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[z[i]+<span class="number">1</span>]==s[i+z[i]]) z[i]++;</span><br><span class="line">    <span class="keyword">if</span>(z[i]+i&gt;z[l]+l) l=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC自动机就是把 kmp 放到了 trie 树上，通常用于多文本串匹配，子串问题。</p>
<p>与 kmp 相同，需要建立 fail 指针，即失配后跳到的位置。</p>
<p>对于一个点 $x$，我们设 $f$ 为 $x$ 的父亲，并且 $(f,x)$ 的边权为 $c$，则 $f$ 不断地跳 fail 指针，直到当前点有边权为 $c$ 的出边，则 $fail(x)$ 即为出边对应的点。</p>
<p>与 kmp 不同的是，每次都跳 fail 太慢了。考虑如下代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nxt[x][i]) fail[nxt[x][i]]=nxt[fail[x]][i], q.<span class="built_in">push</span>(nxt[x][i]);</span><br><span class="line">            <span class="keyword">else</span> nxt[x][i]=nxt[fail[x]][i]; <span class="comment">//优化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，若当前点 $x$ 没有连向 $c$ 的出边，直接连向 $fail(x)$ 对应的出边，相当于路径压缩，这样就是线性的了。</p>
<p>AC自动机上的点对应一个串的后缀，而后缀去匹配前缀，就是子串，因此 AC 自动机常用于子串问题。</p>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>后缀数组将字符串 $s$ 的所有后缀构成的子串都拿出来进行了排序。通常用于解决子串问题。</p>
<p>考虑如何去求后缀数组，暴力排序，二分哈希求 lcp，时间复杂度 $O(n \log^2 n)$。</p>
<p>但是这并没有用到后缀的性质，考虑使用倍增的方法去解决这个问题。</p>
<p>第一次排序使用当前下标对应的值；第二次用当前排名作为第一关键字，它原下标后面那个数的排名作为第二关键字；第 $i$ 次用后面第 $2^{i-1}$ 的排名作为第二关键字。</p>
<p><img src="https://xxzx.moe/wp-content/uploads/2023/10/字符串1-300x239.png" alt=""></p>
<h2 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h2><p>求以每个点为回文中心的最长扩展长度 $l_i$。</p>
<p>为了避免分类讨论偶回文和奇回文，统一在间隔处添加特殊字符 ‘!’。</p>
<p>接下来依旧是：从过去已推出的部分来优化当前的操作。</p>
<p>设 $p$ 为当前 $p+l_p-1$最大的。当前要推 $l_i$。</p>
<p>若 $i\le p+l_p-1$,设 $j=2p-i$ 为 $i$ 关于 $p$ 的对称点。画图可得，$p_i\leftarrow \min(p+l_p-i,l_j)$。</p>
<p>更详细地说，设 $sl(l,r)$ 为将 $s(l,r)$ 首尾翻转的结果。不妨假设 $i+l_j-1\le p+l_p-1$，由一系列定义可知：</p>
<p>$s(i,i+l_j-1)=sl(j,j-l_j+1)=s(j,j+l_j-1)=sl(i,i-l_i+1)$</p>
<p>接下来暴力扩展即可，每次扩展 $\max(p+l_p-1)$ 递增，时间复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    l[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=p+l[p]<span class="number">-1</span>) l[i]=<span class="built_in">min</span>(l[<span class="number">2</span>*p-i],p+l[p]-i);</span><br><span class="line">    <span class="keyword">while</span>(i+l[i]&lt;=n&amp;&amp;i-l[i]&gt;=<span class="number">1</span>&amp;&amp;st[i+l[i]]==st[i-l[i]]) l[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+l[i]&gt;p+l[p]) p=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="CF808G"><a href="#CF808G" class="headerlink" title="CF808G"></a>CF808G</h2><p>如果匹配的 $s$ 不能重叠，设 $f_i$ 表示 $t(1,i)$ 最多能匹配几个 $s$ ，转移是平凡的。如果能重叠，还要设 $g_i$ 表示 $t(1,i)$ 并强制钦定以 $i$ 结尾的串匹配了 $s$ ，辅助转移 $f$ 。我们发现重叠的部分就是border，一直跳 $nxt$ 即可。</p>
<h2 id="NOIP2020-字符串匹配"><a href="#NOIP2020-字符串匹配" class="headerlink" title="[NOIP2020] 字符串匹配"></a>[NOIP2020] 字符串匹配</h2><p>首先可以预处理出 $pre,suf$ 分别表示每一个前缀和后缀出现奇数次字符的数量。</p>
<p>先从小到大枚举AB长度 $i$ ，后面就是C，方案数即 $pre_j\le suf_i+1 (j&lt;i)$ 的数量。</p>
<p>因为 $i$ 是从小到大枚举的，我们设 $c$ ，每次 $c[pre_i\dots 26]++$ 即可。<br>因为AB可以重复好几段，我们枚举 $i$ 的倍数，并判断是否形如 </p>
<p>$ABAB\dots AB$ ，可以用kmp的循环元，也可以哈希。</p>
<h2 id="「TAOI-2」Ciallo～-∠・ω-lt-⌒★"><a href="#「TAOI-2」Ciallo～-∠・ω-lt-⌒★" class="headerlink" title="「TAOI-2」Ciallo～(∠・ω&lt; )⌒★"></a>「TAOI-2」Ciallo～(∠・ω&lt; )⌒★</h2><p>$t$ 有可能在 $s$ 中是完整的段，是好算的。</p>
<p>也可能是中间扣掉一段，拼成 $t$ 。<br>设 $t$ 的长度为 $n$ 。枚举左半段的长度 $i$ ，设 $s(j,j+i-1)=t(1,i)$ 的合法的 $j$ 的集合为A，同理 $s(j-n+1+i,j)=t(i+1,n)$ 的合法的 $j$ 的集合为B。 </p>
<p>我们要计算的是 $j-i+1&gt;n(i\in A,j\in B)$ 的个数。</p>
<p>我们可以算出每一个端点作为 $t$ 的开头能向右延伸多长，以及作为结尾能向左延伸多长。每个点在集合中的进出都只有 $1$ 次，其贡献可以在树状数组中求得。</p>
<h2 id="CF1310C"><a href="#CF1310C" class="headerlink" title="CF1310C"></a>CF1310C</h2><p>把S的所有子串拿出来按字典序升序排序，二分，判断即数出将S划分成 $m$ 段，且每段的字典序都小于等于二分的子串的方案数， $O(n^2)$ dp是容易的，判断两串字典序可以先预处理出每两个后缀的LCP。</p>
<h2 id="CF1562E"><a href="#CF1562E" class="headerlink" title="CF1562E"></a>CF1562E</h2><p>$s(l,r+1)$ 的字典序一定大于等于 $s(l,r)$ 。<br>结论是若填了 $s(l,r)$ ，则 $s(l,r+1),s(l,r+2),\dots,s(l,n)$ 都选上一定不劣。</p>
<p>反证，若 $s(l,n)$ 不选能使答案变优，则一定是增加了一些字典序小于 $s(l,n)$ ，大于 $s(l,n-1)$ 的串，我们发现这样的串的前缀一定是 $s(l,n-1)$ 因此对于固定的 $i$ ，满足条件的 $s(i,i+n-l)$ 最多只有一个，如此归纳下去发现不会更优。</p>
<p>因此可以dp，设 $f_i$ 表示选择了以 $i$ 为左端点的一堆连续串，最大的个数。预处理分别以 $i,j$ 为左端点的串的lcp即可转移。</p>
<h2 id="国家集训队-等差子序列"><a href="#国家集训队-等差子序列" class="headerlink" title="[国家集训队] 等差子序列"></a>[国家集训队] 等差子序列</h2><p>只需要找出长度为 $3$ 的等差数列。</p>
<p>$i$ 从 $1 \rightarrow n$ 枚举这个数是否可以作为等差数列的中间项，设 $p$ ，满足 $p[a[j]]=1(j&lt;i)$，那么判定等价于存在 $v$ ，满足 $p[a[i]+v]+p[a[i]-v]=1$ 。</p>
<p>可以发现不合法的时候 $p$ 是以 $a_i$ 为中心的回文串。用线段树去维护一段区间正序/逆序的哈希值。</p>
<h2 id="CF1598G"><a href="#CF1598G" class="headerlink" title="CF1598G"></a>CF1598G</h2><p>加法运算的进位至多为 $1$。那么其中一个数的位数一定 $\ge |s|-1$ 。<br>若我们确定了其中一个数，记它与 $s$ 的 lcp 为 $l$，另一个数的长度一定为 $l$ 或 $l-1$ 。</p>
<p>lcp 用 Z 函数求解，两数加法使用十进制下的哈希，随机多个模数。</p>
<h2 id="好题"><a href="#好题" class="headerlink" title="好题"></a>好题</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>将长度为 $n$ 的字符串 $S$ 分成五段 $A+B+C+D+E=S$,其中$A,B,C,D,E$ 可以为空串。</p>
<p>最大化 $|A|+|C|+|E|$，使得 $A+C+E$ 是回文串。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>首先 $A,E$ 一定是原串中的一段前/后缀，且 $A$ 中的一段前缀是和 $E$ 中的一段后缀匹配的，可以发现对于这一部分，能匹配就匹配，一定不劣，然后就可以扣掉了。</p>
<p>现在的子问题变为，将串分为 $A+B+C+D$ 四部分，使得 $A+C$ 或 $B+D$ 为回文串且长度尽可能大。将串翻转，$B+D$ 的情况就变成 $A+C$，因此接下来只需要讨论 $A+C$ 的情况。</p>
<p>分类讨论，枚举 $A+C$ 的回文中心在哪。</p>
<p>若回文中心在 $A$ 中，相当于 $A$ 的一段后缀自成一段回文串，剩下部分在右侧存在匹配的部分。贪心地想，$A$ 后缀形成的回文串一定是尽可能大的，用manacher求解。剩下的部分，可以将原串与原串反串进行拼接，就变成了lcp问题，通过exkmp求解。回文中心在 $B$ 中的情况是同理的。</p>
<p>代码调了比较久，列举一些错误点：</p>
<ol>
<li><p>manacher中加入了特殊字符，去掉的时候，注意是奇回文还是偶回文，它们向两边的扩展长度不一定一样长。</p>
</li>
<li><p>exkmp中，由于经过了字符串拼接，注意处理边界问题，取值不能超过原串。</p>
</li>
</ol>
<p>以及如何调试：讨论下来一共就两种情况（回文中心在哪），可以尝试手造两种情况的小数据，看看是哪部分错的。</p>
<p><a href="https://github.com/Buttiyeeppp/Code/blob/master/HLOJ/C23151.cpp">Code</a></p>
<h2 id="CF547E"><a href="#CF547E" class="headerlink" title="CF547E"></a>CF547E</h2><p>将询问差分，只需要解决形如询问 $s_k$ 在 $s_{1\dots r}$ 中出现了多少次。</p>
<p>先将 $s_{1\dots n}$ 建立 AC 自动机，构造 fail 指针。</p>
<p>再依次插入 $s_i​$，将 $s_i​$ 的每个前缀权值 $+1​$，并处理  $s_{1\dots i}​$ 的询问。每次询问的都是 fail 树的子树。树状数组维护即可。</p>
<h2 id="CF587F"><a href="#CF587F" class="headerlink" title="CF587F"></a>CF587F</h2><p>和 CF547E 很像。先沿用它的做法做修改：插入 $s_i$ 时将结尾的点权值 $+1$，询问则将每个前缀节点子树求和。</p>
<p>复杂度瓶颈在查询上。考虑分块。</p>
<p>若询问的 $|s_i|\le B$，平凡求解，时间复杂度 $O(qB\log n)$。使用分块代替树状数组可以做到更优的复杂度。</p>
<p>若询问的 $|s_i|&gt; B$，将它的询问单独处理。将 $s_i$ 每个前缀节点权值 $+1$。插入 $s$ 时，答案加上结尾点的子树权值和。预处理子树和可以做到线性。设 $l=\sum\limits_i|s_i|$，时间复杂度 $O(\dfrac{l^2}{B})$。</p>
<h2 id="CF1393E2"><a href="#CF1393E2" class="headerlink" title="CF1393E2"></a>CF1393E2</h2><p>朴素的 dp，设 $f_{i,j}$ 为考虑前 $i$ 个字符串，第 $i$ 个字符串删除第 $j$ 个字符，字典序不降的方案数。设 $s_{i,j}$ 为第 $i$ 个字符串删除第 $j$ 个字符后的串。</p>
<p>考虑先将每个 $f_i$ 的第二维 $j$ 按 $s_{i,j}$ 的字典序排序，这样对于每个 $f_{i,j}$，可以转移的 $f_{i-1,k}$ 就是一个前缀，且 $k$ 随着 $i$ 的增大单调不减，可以双指针。</p>
<p>先解决排序的问题，对于串 $s$，若 $s_i&gt;s_{i+1}$，则删除 $s_i$ 一定比删去后面任意的字符字典序都要小。$s_i&lt;s_{i+1}$ 类似。倒叙枚举 $i$，每次把 $i$ 放在开头或末尾即可。</p>
<p>现在的瓶颈在于如何判断 $s_{i,j}$ 和 $s_{i+1,k}$ 的字典序大小。不妨假设 $j\le k$，$j&gt;k$ 的情况同理类推。不难线性预处理出 $s_i,s_{i+1}$ 两串的 LCP，若 LCP 长度 $&lt;j$ 则问题解决。否则，需要比较 $s_{i}(j+1,k),s_{i+1}(j,k-1)$ 的字典序大小。由于两者开头相差 $1$，不难预处理出两串的 LCP，即可求解。若相同，则是后缀 LCP 问题，类似。</p>
<p>时间复杂度线性。</p>
<h2 id="CF1252D"><a href="#CF1252D" class="headerlink" title="CF1252D"></a>CF1252D</h2><p>将询问离线，并建立 AC 自动机。</p>
<p>考虑每个小 L 形，都可以表示为一个极大 L 形的子串，我们只需要在极大 L形上计数即可。更形式化地说，枚举 L 形拐点 $(x,y)$，我们需要计算 $(x,1)\rightarrow (x,y)\rightarrow (n,y)$ 这个极大 $L$ 形。注意到，若直接计算它所有子串的贡献，会算重一些没有经过拐点的子串。减去 $(x,1)\rightarrow (x,y-1),(x+1,y)\rightarrow (n,y)$ 即可。</p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>经验总结</title>
    <url>/2023/09/14/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d2deb99b9005c08a02d483e1384e97791e43f1b9531db86c7537424bdbe536e6">ffce6ed2b9da911e9229c3045da1ad407976a234bccc8eba39fffb41f91418f40bd460ce53c180ddafc988eebfc84739050b5c173f20cc5bafaf7fc99346c82507d7eb7bc81a10c86595e700478af8522f721c06e22e3f00b21a68bd5e5b095ec2a0c701ae53aa4d52d54e49f2ad9cdac46a9c6d0642438f439bc4caa69a814fcf91baa7d55f096550862febf636ade6f8c80d586a28864c803d5082824426e6fcaa3bdc6904ddaf61d8b33965763a2b0ef2cd4756df8e90d423aff644f9446db718570701c99be4c59b72f78555458431d60d89db19813b3974984df8378495b3545cd6c7b987d6079475a4bcd5c3dae58b2174218b659ffd89a4e31126463b2bcf216216b62fac728dff6fcbc635d32e63ae4e546352e0d4b11083708a7c356d43f9ba31688da2295d95400f264afcf6e323ac75d41642bca241e6519f070228db178cfa65fc1d4db6d9378903657aa988c6f5909e5659f4fe38dd2f8e2e4687c1ea1faf906b79956666bd36683163fa35206be43f6f8da3e332ba47544dc33d564264e470df36b38cc1250216afa28dc1dc6ceea20572d3167bb9d5236c9feca9ae794b1300d33620b79feebeda354d4014e6041555f464d5627767a23c16798c4bbad0fa2ba19b65d6a62128e1c15c10646481ee4db1191b0a56ca9c6721d6e4a1f39714ecaedc0d36e7e6c93666cc6dbad2c1dd84b0af3baf282ed5b3419ed771e6825f11e0f4258d66b4c1de06947f33abf418fdd5c56023710929724989b3bdeeccf85eef4e8e405180044ae0b2879a83d87fd3b5605cafbc36627f2c78967c70855a55a629d5c1451780cee7f09da6b9758370adb4025e95e02960485c4ca261fac7820ce4f7963cd53161da6947d56adca6ef9c4f5f2ca5be2d0624e9cbdebb78c39d18e5a32aa8f69f861c0265839a9a5cd989d24306ff5d88344ebbb36ce6dcf24dd5663d26f5ec176a6759dc51f312d7e130b755959633b1eac30de4f245ab4768546a8c99bee6baf38ff52b21372b4561732af0600a1f82ba4ec922f37891a7e47cab9cc27f3c82a3403cffe6430a71357061752bbb08641d48ef9bfe8b156af3e02e01b518cb77be946dc323935bf18cf939f85c57b8d49b8d1fe6a899c853b240f86f300880a81910b2b3c73b7438da03c617f19129ebea3b35fe1de390e88fac8c5fe7647bda2c880e307fbd44a6209d367e97ccc8ea7f9f6b3c072da7c16be7aee9d36c74d4581f8fba7fb73f298b8ca6a41bb337e47fd9cabed5cfb33fa4d9a5840ed9501924bf128eb327dd95adaa309c0d8bc12eee18bbd4d6f9578983a9e0187aa67364a26204313d8da56688a27b88288874e5fcafd9c4b07079242e84cb1cbb9620855d6fc29a9f1cfd33dcd86bd7c4523575f6f348b2455066c15413367244d21e38065cf566046671991ce98be040a4ebb37aeb92aa21bb2298d0bf4e2089211538d43eba55bc88c1aa177556360159ef5ced2911a2f69ebb10591ad34d4976440ebe2af46fb6d3c9b3102a92f17c88d59cac13a7ce0b9c9e325faf5de1e7c8eb5020de25ba750c90300764eb53965ef824d0832d93a75691a433f8873c92cea7304d2fd16e30983b9df145df8d23ef12c0081ec2fc4c35c4524946ea15be4b9f7687a46d6cb6e4927d7cca94a9a3036dd450b7d334535ac729c3c1b630d0f96e13fc7e1a43fc8f9405d0500ec90c2f6df25ffd34d3599dd8a9f015987334d424e5a79341f8fa5949c05f516897a19f34f441b241adae1f4910f90d61b7fb0f827ec3bb5eb34e3010296e8d6a36332940d7548aff397eaecf6515b7a96a79ca09d3b1362a1aee5bb7f07b07c95f835715555eee7be37426bf0b269cb689f32bccd892154b46659fdf0e206d2aef54f7106d0278170fd38ec8c7ff5e0610aa68da88de6608555577fc33c38568c1bff25e332b0250afa2d5679ba4a664d245a8f56f9972372c9891440d310df097c68c01a1b9b08c76074aed21a9e9b6ca2da9312a31d4d21ec1c6f81a8cf4bc7f364de67f193890ac89f7eb2a25876f0f34f8f0fdb985aab54b127f51655724dc064faa65a1ae247c427c403280a303315acdaa3c459f00d48ab81b5a81bf66f48790aba96ee4299482622373d96bdf4159a623621a3eb6068ae30993b8da37a64335e82dc46ca38159d04472a5f472710a64fa023f9ff77d4f4a7dbfccecff60afa0212dab16e8f6251b35e22ce74080e9efd5933cfa5f22ee52662df662e36fc87f6bc7d3cebbdd65a3ee29a94fdefb6f54854d41481eb68dd5e623b749b64dfbeda9576f60c1b8a7307cf2bfc62791ce43c225574db825954ac3761d418bf71117803dab803140cc475defd7889a2318cd911df69403305fd2baa2ed63a5b2d2aa716f9cbaf001b21a05cb16e8640ae456a9c5541f906e2bee1a1dc3b7d55bcabdaf14e96e7a8cd39303e56613be9eb05c187e27b9c03d7ecde6ae8a785de12af193249f0e56364f8a5a0c9ef880d2b81f52531f101ac43f86e4ae46bc73029d369ab8abb2c97ecb5ad6d3b9ff16da3e23d5b7d2a9594cc42ca7726dc5530eb2fb0b4e6b06368739ac543d3e14c03f39539c33b2b4c3d3f704f6cc0754de1d8dc279f9c8f2567d2d7128f05d2394a06c8aea84ff9b63e456950042ea73a739c0ebf0e5d2cc8ae384fbb1274c7f47e5f6793d0a7246168efad5357551c1a785d3f11adf56ee478a8f0189239e1cfa8deb1b5ddb9edd4f078a4afdeba8228842543d896235b07cf95b7e748c3a72f0c855ca4e01c5f59184833e4cec13064eef7d051d675a17ad709c468554f01e29c1a36910eaf86a2b98ef704d2b63d63884ead056402b1ac7daf49d7e4dc4591052203b6bc60f2ec6301baee801cebcad303a2924873f9bbc583c72257fd2ead0de26466a6728e4fb22bbc18b0ad82f04191844431e82e52a00a1d9fb91aa272266c2ac4ea7140c2557736628bce33776e7256f5bedaffbe129aa6b4490362b2dec2b17a7825d8ed4ccb3b786ac9acd32cfa3d2aa40c9e3d64b157d787c9f3d2c32097dde4711f7c5ad4956640b3dad285f8b9e8bebcdaf177f832b6ede43c07401d245eb24650e6262b739beed98d98c842de15c6fffc1b8fce98fb9aaaa555cad54e550ecf7fea7eb57041353c4653571e54d8b139a830f0c0a3c55094957cbf2073e132935fbe60fe763bd40eb7ffe2378382e1f13d2911cdb30b56c2ca033b0cd9c314cff72e0b03861a994cba1920efa49d1110cb75de18264c580fc9cab6296684a633160129d972b7150574b6389ad3d12a9e15c258f0db6fe4cf947376b843a78f8e32c598268820b089ae2a167f1edb23984dfe50b18e38235c2b3f5d98c884dcb61ff3bf0c92781d363895a2658fa0db520292303569935ed5a2a324751784cf550d2e0176affc486db2f316277a6ebff93c576d7e46b8e08130dd17e0fa0d99a45b4a513937d535e4467062546828c6788115c1b869ae46ffe1cd51877a8d01812a94ea9fbc36bc7a73ecb2fe54f52a3f5a6a188a023ef41ae15884357484cf29a45c72dac893b1c4dc9d7195593b8c1402281cb6acc961d55b0357dbdcf68760781fc8b27652a0a062c2e21046ee8767e5db2280b616dab3de716ad5f93c1cb3ce03475c930b7473c0cdd2309feb7ea37378cb50428a9c4a6267d6c48183ab7c8cf96c1920dfef799034cccdb540348149656d2dcb8e77ea50152d1a5c7880fa6dc2b8a9a6c5ce777ef36990afa9aaad61951cbe27f1acff755a602cbc3c59969f0ed2cdb2cbe4143f0c873653e33066847ed6228c7bdb0b87853b89f5aa7a479f10e7540097465e5a939a7d2b079e34310f3e0590b746c844ceda4768f6d4d8fc87c41ab3fae25575326fc140c944596a7af6cffcdd608eb59055270b26f59298976d3fd6feebf61c4c0be83166f573fcf23ef91769d5b6ceffccae5ab85c9ea28babd379ceaee81e0a4ec93912f463b4fb0f6de6b2f14b914f22ee52a91fca48608c62e8bf8a7252550bb94099a4249a2e1b4f45471d42968233e08bba2d229231087ca5d8e425fe89d06052b9c13cf95f9487bf098ad724a3a5deec466af9937335c90fd609270e7749a363eba5d402d477755e5338d81fb8d45533b99f269f481a52da3041dbc5cc18972f78cf22e9fddbb295302404658a0bc4b3c572e6278e1d452b65ac15df6e443e7acb0ae52b65466c2edbcf7c34c83830f1a8bb986a4f11ba573340bec3b6f49cc9962a46050da9137e179e52b7c7fde380ac370f96387e5ada80478d1c7b1eff404426769d3d43b00544b068154755d60a2ae9020097c8526e1f2abd27588dffdb3e9c8b4eec4fc82461d8ac6b5e68c8ec5cb1ab4337f296bcaf1838404df6b0c56847f4b17275f2f17fdb3bbad621a71960d3696abbbe20bf2892139572b2b2359e49f6cf2e3419d5c25f3c860334763583ed8fff9757235cd62df86f0a1d088d0c464cd5c8a5dbe47fb8879d875905284266b45a3b587f7347af56ee5700b5bc4a9ce7fe83b6d0543a990afb6c67fc4cc41b13553b99ecec70baf424cabf687ef3687ee82d165f9c775614183b76f0a206174882030d1c5b23713a666d2feefbccf4a7f5339336ae1bf43da3cc4bb2938c8df639c3132c72b77b708ac1911247b00411b93045da1ae51f8b53631d522b1bfd2a6cee2d4a91251dce065a1ca90e36c9494a01e4e25e80761caf2d706b2518615342dcecd6d7547eb061c94176f95114aad3be7a5ed9b857dfda2da3b9c9a6c8daa4e53a7134af729c9beb50c795a059127cb5b3046ccd4051031ac373c5c1325e80ba7b1aa0d585fc0fdbe4c9093fdcc1e1743707770489115928a038f979bd6bdbbbd2bb8816f6e0df5fe82ddbcc8bf32497784dc2d7db3774acf6ad8456b0fa211e674705132f0b8fca4fb57dfa517e4ad2509d69f379534803d7f866fa2cf1de6a39c0d5be70ef183431af975adb274e9e47cef9dc38b0829fb43c7876488b9f38fdbcf4b359300a78652793d8895181da99f2063f78c2b630c69a65a2dd25a0c1b5049bc839bf553b42dc50304ed118fad39c2bf29d57f24e926eb09b46b52357d54d127030ca33f7cb4f8f77acadab01137b3469d109a54932d4639f623ebba885accaafcb90750ba9483b622a02201889a73fe17a51aaa4848880bd5fc66631fb9a59375bd121adfdd24d7c62efcd77506f3889c427e602a8b2a82e0f7b849d0f1a62df2a6465ab662986f3081330841688bd2af55609b4bcd8c9832ce3f5ba55ba588407ca19c90cb063c567476680c3bfbb4909fc2cdd5ba0a9b9cffe47cfa94c0412cd29b11e52d7c2a406f9ae779ba5d0b404267ed5083f7d9426a39738f1cfcb1285e2f0dd51aaa908c374a470f58472db05623f57b06bc9a251f1dba9c5d118df4a5217cc29c6440882284f73d144d92c2349e91f81dcd2c4afedf4c53af99ffde5ce1864252adab6771eb727207314a1633c845d0cbd458f2d34cbdb1424639ce2a2840b33321e15f11d0f4c56abcf683b792a5d0d6c97fca480ac4fe10d78b2e9f6d8535fdfcb6d2036adb1e12d78f225ecde2141c11beaa43d801b5c5102755b5665cfd479e54cbd4e8a9968242f2f3de1827498f3531d455da263b5532e08ab1160944ea1e5e368d4c0b1f4f9654a0c7d59b64a8a389ae8a1630f8e1796fbee375bf7fd49e87ab696bafb7752e13094f0d6b6dd3b1bff3a67089a397528d381c5e225f5c42d6a0608ba6099b6137c15fb57dfedde480d8e2b3951067d3593d77ff316c7f883587951b5682cb351d4118bc838cb98a1aa62765b2a729af02ce4a5d605b64716a1f99ab6fa8fd5964f6ccaab3f60d21c8ddeef21e5b519658b62cc28cc352771d45f814a232ee2198b5ab0c117a4b0cc0000ce2d4962afa44fe6617372a809f9329caacde9db5ff69959716f3ee88aff8d33c92204dfb4a3dd7e009619e02abfe0c578b1c2fd72ee8d9c6126aaf4dbdac4ff356fb36009ed95017d5ff607bbeab1bd18fb8616429d7b94ca7f2b59a0f501d5b9c46a9a1d637c4ef432d89328411be553cf53e0943811b7d72b38661293a1fe8a90bed1d958404413e6b9c8e9fabc117d3157533d924c4a51c3d7a9da299507febe2cea38bd321812a8c20070bce9dc83c1bc573cff7a44ee4c5ab849b2da7f0a07dfc5135effe11b7df63ca4bb9aca1adb563fdc358a9b7ad2fb9144ff56c08bfcd8c04ab4c9c764bd5dcd8440bf09f24bafdbb00064c0466fb2bde5079bd6a1f7984bfe48c8bc7b35d79b6f074b0e5d4fa7500c3e6c169b619636caa69d050a67d18ca66784ead9413a4fb6b2108721441077c9909c362177a38b7703a0074961aea78f27d6455ed9e5f13fb4e0c4872bdbaba4e770b1b19b04f706dc937495c3fc50a6cd107b372799e4573a6801f0c9f5f74e3bf33b98e92a669fa03c4a24cae468cf5bb85fda07c95b3e00d05680b961103fc325d8272fdcb93b56d879bb0be390d7026bdb87298b479edf73f7523b52cea6a0936d329ff2b37cd570e1b67c29153a0bad452118e7761e252c9066805c12a5cf7f31a4261b4b29be3dfef7b853e62efacdf62d3d36c847353ab5bfd1e8c506fb18b7d4ab950ab44d6c6e4d43a76a8f29ae502df36b327330591dec1bfd112b5c627bc2a186ea3057e820d8f71893a7b20144c64ed09a4a5a2094f388ac665212947491413220f5dcc7dd5f0239526cafaa637a9e9481b68e25877614dbe857d42b3ddf941a4a0ecf9ef611e990eed1177024dd16237388ef0e6e526978736b8f7aa45a27feb967b5a8f6052ddeedd1e13554235af43761e829cc9f6555ea6c89dcfb1402e955dec9de4ead6c961783ae22313776b33f756b98671d461702f1e94fe1b63fbecea3483502766ac4cb7e23bbb804e76e45b5afe776e196000e9e81f06f1ecdadb9fe0d4181c0e042cdc1a640a4cadefada240176c9ecfbb8b294cf46ec3e4828eb1fed2f1d2b67b01f95a0434e409c291232dd486e58726f7ece311945a47ce9484f6215e9bf473d0de1f7665e8db30a869c0275fc1d70f912fd9d558b9eb687c5fdc781e820e3e33228ec3155cf84c6bf07eb7f06124ca969f4277322af8b079efa171372a4596f31ed0bdbe457ee334d2e9eabfce6c01fff5d9ef049556db5b573b6b6873fb9a971f44258ed78ed8abdcb795c59d1a62911437e55f147e34d1a68680ea9c25dd8384b059ae05163d22b2f9a4a686a571498cc234a438260e91fdb19764f0f2d7ca393537116dfb34bebea7cc0d1a822e9664b0191179b740a889a8aeb4d535564b5c9e85e3406bbb0aac163b1719d406ef581d8063646554bc7ac3561b0da4b663f0470cc7d89cf4e628f2f3558b5f4968bb4174df94d2a741f1e7b3d94af7609a309406c37da666293f16141296c75162d3e403f685d07603c6b16c0690b4966633581ba4fccfde5ecaaa81559f2042c94d9e676cd7a3337a77439eeda68550fe0d526740b76d6819fdf0db0a8fc0fbcbba380ff376bff5e72c62e5ca6e38028b1adc24c8c33a93bef925ca3fdfc57de3b88162fa62244d732e2c82a28914ab3e0d307e90f127417b032eac5c4c13879967245e11b5924f081afbf20e1173f030aea59c745f07980d153d355956d23a23cdc96fb43dd948ab1ef12df6947a37e6cdf7f5af018dddd43e6575997755fa49443b6c635f9f4cc4b5657d837d4c2d932d0876138f4bd3d48f4004f511d97dba1a39af54af9101853876aff6984ad3a2510b63b6970a7a2abc41d674905873d54f566e4bcf17365e580026d529dbc44015cfc9d2e28d9bbff0564517fa50e4b623966d0a9f74dc515a7fd8af7aa2afa99993e58c471a9fd95a95c897551f89ba98eb52b65333eb5c4d63da4969ec42745bd13f2fce573cd62ab5480d821559c476db3ad96fdfe859b94ed74a73bdde489cbbf24a7e02b9f3f881e5218e650b95f11c95eb09d9fcfda2ce25a5658b32b08a6ef346edb16750d33fe678f46ed417a6daab3bd323e48c55572bb0ba96d257bd58d31a1e179034c605c9e23a32e44b7a58576b95decb38ba9b8893c6cf82510f9ed6b9b585c71fa2f06380ff1c21198cd482b62252d2fd721711da1d2bce87f6bc121b34d4d8a6e03de07cb99145da61975a9c37074b973e56077eee739148bf2ec58a1aefc8f47bb7ad08fbcdfca394c25f56f20a85ac8607d92fe45d39098aa5e008988029ba4c191ab62bbe02c1326a9c8beeac3a815151882f18cd67f48af33510c445c86c6b63c93d8082b422eef03e2f75b3e01a274cf45b3ccc8ee28affb1e485949dd976f9c0d720e813135e02a0cbab2bb6ba81266c3ce4c5aefd87740b15f227491d73fa4ca26825a1424c7965f716666b860232fac2ebae45b2a92fc8f7cab5332c6d40aa781cfd5ef8b47d5463e1e169c5822117650ff041fc06ba1c686f0698892c14b19318c844d762f5f1180a8828189aea46afd2648bf71961fef2a9459091baec087e6dc66c57ce7c43687f04d2073867dceeb7267a1c6fd1e1e6a52d6283ec69f47283e19544bf2c72af8154f62f4420dea2aad5966d20418f0d75fb323331b569244d8c43054e1222628442752e3741aa04bc5ed3b087ec89df73dbd2b96c64a3598427d833ce6e97bc9d8d8cce97e94fff77f42f3673f4e2016a3a4affd6e35a1e6e801ddf278712353699d5fd12686f392a67b94ddc3dc5555d078e53617ce38163b79b8eb61ed20a0a84de1747ef9864ec256edec02e29feb2fd89750ac447862608c5a9de2569c050778619b63c823dd11655bc210258723d87b19bbf8de0bab7a83825bcbfec1f59c82a565e3418c1770e3d84ec929ac05bdd1b0471c40fd95f34c3d33c1abd5ab907ba477b425fe9ac07e50606a4af396c48271104807aa0afda033425051ac88eaa9ea0da708fa841c139e555e7eebedb36f65a96e50dc7fa036a809b75c969b35182116e62074a3ffaff9e0ae429a9454cc554bfb8bf96a9edf003be889e77d3e7784c897ca0773f9cacb46d414cbf31e7186f609b6a4325e59862c9d4207559203ca56fe9c8fe1da69ec5209b5b06a4319175aa2e0957ee5261c90f4cbd9f9a39fff260f9273415c80e3679cf7b8ba2d6e24481c0ef75bbd2286be12bb1c56683797bffc2361d81b8866b5e15cd105a8ca17e94b84a9f5e62affcfccd7bf764b1dfca7ccc9f517861292ab02beb614aa7b996fa902a050c1ffa35510d9f5379aa8c17070f2e69c0ad972ee378f8dd2fe618217184958d815084375fd1e068ecbce281107bf6e4a062371e7ebdaed5ac21faf2718a4677dce3488c253218e583a9f5ad597eb8d11348f6019b3e72797e4aebbf2a14e3a13c2eb9125ee34af9aacf60ec3cdaba9c08a65dd4e120cbb556debdbb27561cbf7575e311ad92ddb3a16d8247d23fee71102745a74eda1d936163fc8f07ac7b46c95ebc458326ab7c483d8cd764f8f1799682581a9517cb0b64dbfa3c8790f6e5afe94bcd62bc6774dc00973732dd712d3e34e4a577680a5db9ff3472a937ce42710615a07cf5d3e7c31a766e1d585550c6775b59e652b8ca6e1ad0590fc484afd8cc85088d676434976ad088ccca9303e6592bd5a3df88fbc14c21969d328823cb65b593391fadb4aa2d70c7125d4cecda1904906a90f470a0b8d0a152bd9d2eec008f7ce8f2366300985d0dc6340d19a8415a823a8b40c7a732b59484fe41bc8423cd668beeea052e8a3eeaf69b659e9948cb1270ca19ad4b7351e05540e4e276bd3863533bb7148024ac97865b0755491d41d6b445645089cf032762821a4c257c96eac27ce4935f0226352f3205c813aa77d08b52020bebc202655c25029b7bf5f417950b261967f34ee5d40bf08c3f67b7f542ae1ff20b00319ff376b1501bcf70340f7eaf16045a035414f2b5a41a0f5c59f560d94a86c26d754fde77cc2ff1741e46ef82def14ac315ebfc4abb911140b68e314c30978765a01e5310f9fb270ee7fe10af96703bfbdd8c93c16d28af7f5847a514e3b68d224562ec86adfef8c63eb5ba547110a0495c377e9c502c1da3c1df8e9a699041b8b0c54932cbc5f6cedb9c623d7461263ad57487b6fb01095b3b3ebd182a9feb99632d4df51367b87e15def88543ba59c0239ef69c89062811926c31700c04b2a4b339b8a3a7a5b3a4b6846ceaa2c7a58bcc38891332504605891930ddc8148d52b51b3f11dc25a00312b98188b1f49c212af459b7c3e687c39e5439ca408f2bd1632bd551528ef30ec8cc0798b115dfaa58bb7e2c5fc80f7fabd25eb85760857888d319260625770c32291abfef373501325b8a78b02a1e642c2ad1ce7d29d9f81892c08a126c858b3cf0419217446f20861bcdbbd08381549aabf796e9cf4b395352c8c963eddabd95b2fe72e49a4222f2d043c9ae6d06316e7182c710a557dc94521d682373db5d9e88863c4d3fe27f082bb5411c51448fc09dbebcef70ea046655b3bb0e48f0d29f91e8ad76778e54ac75bfed171644c143f9cacc9d1a6454eae535f6d85448e44ff0dcf2de7548e3345ecb63fa17b017288fad7e6680f3a8a502de2d01f24452da8250361755c038796f52a7b1ec8227ef76d83c18baf707d06fb9aacac4851216f9d7f0fb90247a8113f2d84b93bacb16b6ba0f28ba92d3e3d0da283b2d85e65fd62730c017e8728a95acad68b1c8144e3d52afad0cf2b2a90cca768fbdb248c44daaa4c66d9c1a138e2afa03769ac98c531892c010bba92e7e6713fbfcb59b970b595c8fd0b8a05c6ff77cefdc24b482be1d6a3f3ed957d1bcd06e77f62582313a9f01e7b3bf96cdce96bb0f36a53fdc24cb1323bd017c59fc3fd02656ebac806a76e1e86ec59e50952964fabc951886d624a66f4536cb5ce89bbf85b5ab3599b32be17fc78d09e02a831969fef8e2119c3c27c6fb6e2fd7b092438f23d5c492faccaea9f0ddf115528fb939121725bef7bd74660b497af1bc6be9b75ccf51ec6d81acf736fef3ee2cf75550aebc49befbc9cce9b7d8a36118926e7523cea24a30abc5e93165598b7219bc55c0250526a3ff727adc8bcb6f4cbeb8ba93e157e24d234d8ccc3fc5a249fba4c01de4a9c934562b979f81a1a5fa99b5df2cb940d7320e93b0b409f8bb127ad5670d045cd9e8d26c7c730b4617be3888442bc943312ab746cf07b7c6b24281abf24d6217653ac460b85e5f524717aed41c72d12b0d92fa749bc56c9a2759e5ddf23c221392298142a4e7cb3e553370accae4be89db4e1e69f03b19b47b4c92323015d6f0749ea53310f46d69b62490711f84f10b189ccbea8d83ee7db89da6ab04c851c8c85d883bfffd17b78d943d702e6b1b38ba1c5afedd27505dd8c30b13cae37fdb4c61c3275b74f69f5ad23da9bb716e1e113f538ff8f625834a0a1cf65308ec361f0fa75c5cc9940d2660dd0e8c94f3a90ac63e89377f25caf0bc7303fde2293be8532ea9f26cccd7ea1097fd7f34d112a90cd8bcd79ba00421f8e1197cd076ead5a4e583c07060bee1c0ccb16e5c3fb43cb49eb29943c9c8aa572dc73f0ed2d5d9b210f8eed6eab24ac6d36168672e0258d4d3420cb40b7d7f41d1eb39539162e5688ab52c87fd342d87c7dbbd97005b1e50183bb04f4673e4f0de18d4e0e9f5b38549ec5b5e56e3724ac341c5f6ec5188df68e8e55b6fdec61077269be0567fdde9a967dd97cb685e3aa5a885eccb26122daf049b7f5eb7d283d02f93ce50ca2b3e923abe7f9d286495c70cb4b4469808b21514a50b22796e56302c1447599203f9af74a119f23b1df676ab273a9a5f9693aeb5eb0166da88abdaff8ac59c52bcfe5ddb481636de120603eab0da12d8cf622a7e66f044ab22f0c5d6b204563be4af20f848bcfa84baab4f7412db031f9808ed45e553e3f331343e18c414edaa492a41a64408afe4147c9fb956688b62094e998004c9b1e8380425ff86dcb225660aa26c45f704e212e2dea817c4135ea0736ae0eaec01a8e7c5a52394e9131fcb12277b1253ce31ee26652ed22ba6d743af6e7a445e43e5693a0e5bf885ba09c1ba9b9aeb515eba16421bab73093c157a1952b93bca028e3cc441f772bca198cb7875257378db1e3ae919bb786737a1a4eb6cef1284765b1e50dc27a822a57596af9a52eacf8c82b20971ecdb60a825125f55a0227c9fb80cc4029604d954be104ec43dee3b48728a031475a354e792210ee6480196a4fe32ceb1a602cfeaee03cc0d5b5d2d91cfe04096fa2f4a5ca8d00642a5e784894a4495fcdec747d2fe5b1409f013c3c8334f24da342448a1cda39e7dcf3d1c8f1618a9855e669ab2459b9e4d4e12bd846fecd566e8781bba7c4298b8b8e38991bbb2da3e7dacfdaab7f780648fdd016c96e92ce43fbaa0f66be79d4fc92017640132951679f53790e50fb1b1c87d8e97357536d4141060e40344558343ddabb30657e35a6c8b1a0d52253bb8bb968b555957e727b8b6104ba92d9256fc6b2c1281c66db658173174d0724d385411eb685dd466080f8ed532983b956faf2088816b7063d4ef6dce8ce44fe84aa8eb28f74fa30f869d90fe063d37dcf81a09cfd25fd9b1e100d46c69482777bb5e18cb3592d9d9b488fc7ea1f0a1a858b23effe7cdee039d0d07b24aeabe937c0e744ff156a223451f40c1a15f3cfe56bcec7ef1022a2d8d99fd07c5a7df59cb801f7b199a7acd8ff4e03030fd4010014040a65d5b60e7446019a796540c5092bb1f3b25ff725511683d8569e75ab3b034cc1db4bb4805522e1e79dd2257c3c74d1593270c4df68b4cd480a3396a42671f14e3eec36c7afb3f77088618e13dab232bef7f25342d997c5c3ceaf5451afbee153836585c809f1bb5c1c04eac9fa356d644327ca3fc112c26171de7297e7eaadb8a97133c80dce3f964050f5dd9feb51eb97993e5c2c6023ea2fe0b8af3c5c9cb717adf100f9e6e651a79821e7d8035a2b473c01b33656bffa58522b968dbe6e0e54566d23bf2fceea9642deefc4cf634b8a0011da13d3371f353ccab73f4293e4eef642a7a390d38ec7fa883285cef72cbfc2a7db78a3641dc1fa667d293f66ea6d1c9fa8633f32825a07295c5ea0bcec2e3afc55b2914be658b071f39b6332348b97e6a08b46831b2f312370668d648dbfafaa49d49387a84df7f4b489a6f2d0660f7391951f250f0adfc9cd10d1a24359aec9057b7b94e6b01792710c264d6076885a0041dcb7dc18879db54afbcb8234d3a4b30d1872ef6e4a5c0970a9b5c1abc913bfa4644553169fc505373dccdbc95343409aca883c207cef55b22ca3f9adcfa2f4e16096c20773708db6aa6ab7e96eea007da7c6c04fe4412bec11c58865f4a658f4cbc1323ec8566ec6bb1e92b9f8db73fae04a72122f06c60b54844e1bec8fa427804eea903678ebb6328eb67ed6d7d6b0af338202549e5e263f1a190eabe0d4ef934e7d9f1d3d96f2050e720e0477fb14ef8adcf1de215786fda4ea756e3d75377a7d4be204b6f0a3930f30fedf224eba5687c6cdfb43995e93d525c14d0c664305eeab270b7c81aa2f40144f803035a445865dace748c4454c063ba5c2419ccdb638c27f29fa257a1319bc85db236e81a6512e9e7d3b889a55c6bfd679227710aa38852aecccf0b7b507a127a29bc6da4c224e70cb4f5d58d54e71f7b029cb2742e019f7eebc96914508099ccd96e0461a2e82b74ef49458d430463ccccfbbd7fa0be7ae91376c677ea4a6e52d294da1f83472947b1e4b6ce7ac23bada32a0b1597fc3375c08f87c02884c6f0f6f32ab3b66eba79e1c215871bbe22bdb0981649a222ff16160b0ff29d70945bec684d084bac331d5c2f98db4855ee241ea1337d6e7e5b36a9975560f079a4939cbd5b00b28de99b54ad5b6a77e03554ca37d3c04e3e65d57a538a5b67346598cf8442990a01625aa843c3737789885798edd888b850c4ca3c8fd459861b27559f29969d83555da7af7c346da0d2cd9f19d01d9421ddec60dfb1b9f3b213a2ebe4a5064b5b06c57a22f2c6c17fa7cdbe55f3e2c44186f9667e6758f4e82cd631699f1b4fdb4e7f8775533b409b1881542ed0169fad06b28bb581aa9402c0e1e123b83496536f3512bcf28026283ccdf87b633cf7cd5dc8f299eddc95c05ba9a61a03ade01f5430acdb1eda9e4416e49b4b257edb776818d6bfed78ee4139eca70299444d0f14d8f9d2124f86df9fbea0e5baa787f91555e77a11fcf2f92386bb5b963bc0bbae9136b0893f1cbed793c723095469658c4fa4d6b2332e982fa776c075274782c6edd7eaf015940f4b86b2b858b1eecc52e4e1ca4f1599e7c8fc0c26bcd4df8d71958c0f9a231ad9ee2a130132c1c2e1366113ecbb2ba4d343144f0a8ae2d1d668054e0dfaa21a23c497e39e4304e6d2d6dd800086980eac2dfe254a726560724abc342355ef385526e21bab174a946a4800e3b5ce928a65e8051ed2108012f9ea85e26cd1f94866b0a8e39b29c744d7bbc7c6722556097dc95665efe763926386c33b8001045a07b018ccc7f46ae9216c0bf06330639e4937c2c105e0b1bcc4100c1223cc285f22fe3ee4d5f233992f822ae7135c40808f2c083f2635e9551696ccd4d3b1c5d38f97e857acf88d7e1d51e712df2d26b0bb906443ca771b466d92c5724a9f2f5dc3464c164fdf4f85923dff2b0d3466f7c38713b5d53b176312200751100f76de263b4da84429cf943320f7ec27737addaf1ec40029eef1c943c74d38dd72d17310d57565a50b4995db2c982939a06f86fdacdb48b4272a32156f7f5dacfa4632406c0fb5d23c91b5422327737f16df5e8d1deb75565561c537fd3c09b086a73b3e95c10cfdfead7c1c2022013de99531e8da5eff7abcc2605734ccd38ed388a7ffd39da5009adb438283c968b5e3ca405c661030910cf6c38be1a1acb611610f6788311af89811a30a9b943d2f104cb08b05bf6d7564f21761ae1ec49ce29bcc4540d9d31ec793905eb2b7de2c993227305e296eb8382ee5e90fcdf01ed7083c4ccc3e6a509ef30670699aac27165fda7f27ac5258944e321f591e2e140b929b11572b7b51a82204658df99e2517b4df49039d5cae7da1445fe3bbe94d14955a8fc47c010042918cd7189fb2d378dd5b19bca5b5c607239aefec30185594c0e88cddbf56de4809af145ac4f05391107534ee8ab3d2e86308eaa1002f6ad7c6ce34aff8b36ae155a246d3b2a98aa35489ba1393adb9dd7555e43616cdeb94aa3e6376d1a8fe0de07f27d4155b763203905920c0f7b83c2b96a4f07b71e2a847dcb507f5208d0894474ca1d8ef44abd2e744618253df8a12d3a45f9b697db148ec34e91e3b5a04b1d93ab618dc0d5f080c5e5c814005285cf51b9d0cf66613f6695f521f6e6cbbf527423a20e035d660d4729aef9875fff83e7ea4444f3cb6613bf25d4ddedc9229719ca4d7c1420b18e430629f9219df29be15bffc21e21d024b027dc2ff08337e5a63d81594ce2cef1dffd8c95cd47e9a3bd327ffec42c3a7841e57f0a9c828a6a48d4b9d35d3758fe5a84db3ec1bb77690aa8eab679b95f00247e9ff69d42cf620ce5fe4686eeee4bcad662b02562fad41a61789bddfa268b0bd095862724f4d5bf36984cd9e3d5c6f369d909c20a1a41547c510f8b0cd37df2e1e7838f7bac48cd72d4326a3dccf4215b9d63c0e6c7b6dcb7325156e7c51ccfd04b193c02a5772cc3e04428711c1b14633a8ca98a061e02e75dec9f5ff10a2314378a170d21ac4bfa8e609b450235e1411177385d5b751f5c76a6559ff17d5b433782021253be51cff42b1b3a8f756dfd522a6bee6752ea9130e441320d18d1e593bda4ebf45c61f336794389fc64dd675e1a35270f9d66b2a8101d5865347e1167229e735cb67d45b376a828933ae49d7f60b0222747793106c24516ef75dfbe8f3424ce0f8f43a04f4c5d4094f5f80d2b9a08f85dee82a82b09d0ec6e59c8dec473a8fe546ba467e89f4aadf3381dda63942809ec0ea925d4ece05028afec4470463cceffc8e248aa03d598c2c6ed3937eedfbbec858713ec3778afc66fe4c3665ef67c20a70dc743977942392fbc23b9cc0a4a1d558b4c2c4d4fa4f042c1d5351e9bdecde8ca64edbdb8ed5627d8940b673e8081633779b5fee7b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
</search>
